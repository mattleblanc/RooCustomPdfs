/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

// This class has been taken from https://github.com/gdujany/chibAnalysis/. Only the class name was
// changed

#include "RooDSCB.hpp"

#include "Riostream.h"
#include "RooAbsReal.h"
#include "RooAbsCategory.h"
#include <math.h>
#include "TMath.h"

ClassImp(RooDSCB)

RooDSCB::RooDSCB(const char *name, const char *title,
                           RooAbsReal& _x,
                           RooAbsReal& _mu,
                           RooAbsReal& _sig,
                           RooAbsReal& _a1,
                           RooAbsReal& _n1,
                           RooAbsReal& _a2,
                           RooAbsReal& _n2) :
RooAbsPdf(name,title),
x("x","x",this,_x),
mu("mu","mu",this,_mu),
sig("sig","sig",this,_sig),
a1("a1","a1",this,_a1),
n1("n1","n1",this,_n1),
a2("a2","a2",this,_a2),
n2("n2","n2",this,_n2)
{
}


RooDSCB::RooDSCB(const RooDSCB& other, const char* name)
: RooAbsPdf(other,name)
, x("x",this,other.x)
, mu("mu",this,other.mu)
, sig("sig",this,other.sig)
, a1("a1",this,other.a1)
, n1("n1",this,other.n1)
, a2("a2",this,other.a2)
, n2("n2",this,other.n2) {
}



Double_t RooDSCB::evaluate() const
{
  double u   = (x-mu)/sig;
  double A1  = TMath::Power(n1/TMath::Abs(a1),n1)*TMath::Exp(-a1*a1/2);
  double A2  = TMath::Power(n2/TMath::Abs(a2),n2)*TMath::Exp(-a2*a2/2);
  double B1  = n1/TMath::Abs(a1) - TMath::Abs(a1);
  double B2  = n2/TMath::Abs(a2) - TMath::Abs(a2);
  
  double result(1);
  if      (u<-a1) result *= A1*TMath::Power(B1-u,-n1);
  else if (u<a2)  result *= TMath::Exp(-u*u/2);
  else            result *= A2*TMath::Power(B2+u,-n2);
 	return result;
}

#ifdef _AN_INT_
Int_t RooDSCB::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char*) const {
  if (matchArgs(allVars,analVars,x)) return 1 ;
  return 0 ;
}

Double_t RooDSCB::analyticalIntegral(Int_t code, const char* r) const
{
  double umin = (x.min(r) - mu) / sig;
  double umax = (x.max(r) - mu) / sig;
  R__ASSERT(code==1);
  
  double integral = 0.;
  
  if (umin < a1) {
    integral -= IntPwLw(umin, a1, n1);
    if (umax <= a1)
      integral += IntPwLw(umax, a1, n1);
    else {
      integral += IntPwLw(a1, a1, n1) - IntGaus(a1);
      if (umax <= a2)
        integral += IntGaus(umax);
      else
        integral += IntGaus(a2) - IntPwLw(a2, a2, n2) + IntPwLw(umax, a2, n2);
    }
  } else if (umin < a2) {
    integral -= IntGaus(umin);
    if (umax < a2)
      integral += IntGaus(umax);
    else
      integral += IntGaus(a2) - IntPwLw(a2, a2, n2) + IntPwLw(umax, a2, n2);
  } else {
    integral =  - IntPwLw(umin, a2, n2) + IntPwLw(umax, a2, n2);
  }
  
  return sig * integral;
}
#endif

double RooDSCB::IntGaus(double x) const {
  static const double rootPiBy2 = TMath::Sqrt(TMath::PiOver2());
  return rootPiBy2 * (TMath::Erf(x / TMath::Sqrt2()));
}

double RooDSCB::IntPwLw(double x, double alpha, double n) const {
  bool useLog = false;
  if(fabs(n - 1.0) < 1.0e-05)
    useLog = true;
  
  double absAlpha = TMath::Abs(alpha);
  double a = TMath::Power(n / absAlpha,n) * exp(-0.5 * absAlpha * absAlpha);
  double b = n / absAlpha - absAlpha;
  
  double result = 0.;
  if(useLog)
    result = a * TMath::Log(b - x);
  else
    result = a / ((1. - n) * (TMath::Power(b - x,n - 1.)));
  return result;
}